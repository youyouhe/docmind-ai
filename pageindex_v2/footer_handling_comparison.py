"""
页脚处理方案对比：正则 vs Few-shot Prompting
"""

print("""
╔═══════════════════════════════════════════════════════════════════════╗
║           页脚处理方案对比：正则匹配 vs Few-shot LLM                    ║
╚═══════════════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────────────┐
│ 方案 1: 正则表达式匹配（原方案）                                       │
└─────────────────────────────────────────────────────────────────────┘

实现方式：
  1. 定义多个正则表达式匹配不同页脚格式
  2. 调用 _remove_page_footers() 清理文本
  3. 将清理后的文本发送给 LLM 分析

代码示例：
  def _remove_page_footers(text):
      text = re.sub(r'第\\s*\\d+\\s*页\\s*共\\s*\\d+\\s*页', '', text)
      text = re.sub(r'Page\\s+\\d+\\s+of\\s+\\d+', '', text)
      text = re.sub(r'-\\s*\\d+\\s*-', '', text)
      return text

优点：
  ✓ 速度快（不需要额外 LLM 调用）
  ✓ 成本低（无 API 费用）
  ✓ 确定性强（相同输入必定相同输出）

缺点：
  ✗ 覆盖不全：页脚样式千变万化
      - "P.5", "5/100", "[Page 5]", "5 页", "页 5"
      - "第五页", "P-5", "5.", "~5~"
      - 各种组合和变体
  ✗ 维护成本高：需要不断添加新的正则
  ✗ 误删风险：可能删除非页脚内容
  ✗ 代码复杂：正则表达式难读难维护


┌─────────────────────────────────────────────────────────────────────┐
│ 方案 2: Few-shot Prompting（新方案）⭐                                │
└─────────────────────────────────────────────────────────────────────┘

实现方式：
  1. 在 prompt 中添加 few-shot examples
  2. 教 LLM 识别 TOC 页码 vs 页脚标记
  3. LLM 自动忽略页脚，只判断 TOC 页码

Prompt 结构：
  System: 定义任务和规则
    - 什么是 TOC 页码（要识别的）
    - 什么是页脚标记（要忽略的）
  
  Few-shot Examples:
    Example 1: 有页码的目录
    Example 2: 无页码的目录（带页脚）
    Example 3: 有页码的目录（带页脚）
    Example 4: 无页码的目录
    Example 5: 复杂情况
  
  User: 实际的 TOC 内容

优点：
  ✓ 覆盖全面：LLM 能理解各种页脚样式
  ✓ 灵活智能：能处理从未见过的格式
  ✓ 维护简单：不需要写复杂正则
  ✓ 代码简洁：只需要写好 prompt
  ✓ 可扩展：需要时只需添加更多 examples

缺点：
  ✗ 速度较慢：需要额外的 LLM 调用
  ✗ 成本略高：增加 API 费用（但很少）
  ✗ 不确定性：相同输入可能不同输出（但可通过温度控制）


┌─────────────────────────────────────────────────────────────────────┐
│ 具体对比：处理 pages-78.pdf 目录                                      │
└─────────────────────────────────────────────────────────────────────┘

目录内容：
┌────────────────────────────────────────┐
│ 目 录                                   │
│ 第一部分 投标邀请函                      │
│ 第二部分 采购项目内容                    │
│ 第三部分 投标人须知                      │
│ 第四部分 合同格式                        │
│ 第五部分 投标文件格式                    │
│ 第 4 页 共 78 页                        │
└────────────────────────────────────────┘

【方案 1：正则匹配】
  步骤 1: 调用 _remove_page_footers()
         移除 "第 4 页 共 78 页"
         
  步骤 2: 清理后内容
         ┌────────────────────────────────────┐
         │ 目 录                               │
         │ 第一部分 投标邀请函                  │
         │ 第二部分 采购项目内容                │
         │ 第三部分 投标人须知                  │
         │ 第四部分 合同格式                    │
         │ 第五部分 投标文件格式                │
         └────────────────────────────────────┘
         
  步骤 3: LLM 分析清理后内容
         结果: ✓ 无页码

  总耗时: ~1-2 秒（1 次 LLM 调用）
  总成本: 低


【方案 2：Few-shot Prompting】
  步骤 1: 直接将原始 TOC 发送给 LLM
         包含完整内容（含页脚）
         
  步骤 2: LLM 通过 few-shot examples 学习
         理解：
         - "第一部分 投标邀请函" 后面没有数字 → 无页码
         - "第 4 页 共 78 页" 是页脚 → 忽略
         
  步骤 3: LLM 给出判断
         结果: ✓ 无页码
         推理: "章节标题后无数字，页脚应忽略"

  总耗时: ~1-2 秒（1 次 LLM 调用）
  总成本: 低


┌─────────────────────────────────────────────────────────────────────┐
│ 鲁棒性测试：各种页脚样式                                               │
└─────────────────────────────────────────────────────────────────────┘

测试样例：

1. 标准中文页脚
   "第 5 页 共 100 页"
   正则: ✓ 可处理
   Few-shot: ✓ 可处理

2. 紧凑中文页脚
   "第5页共100页"
   正则: ✓ 可处理（\s* 匹配0个空格）
   Few-shot: ✓ 可处理

3. 英文页脚
   "Page 10 of 50"
   正则: ✓ 可处理
   Few-shot: ✓ 可处理

4. 简化页脚
   "P.5/100"
   正则: ✗ 需要新增正则
   Few-shot: ✓ 可处理（通过理解）

5. 中文变体
   "5/100 页"
   正则: ✗ 需要新增正则
   Few-shot: ✓ 可处理

6. 特殊格式
   "[第 5 页]"
   正则: ✗ 需要新增正则
   Few-shot: ✓ 可处理

7. 自定义格式
   "页码: 5"
   正则: ✗ 需要新增正则
   Few-shot: ✓ 可处理

8. 罕见格式
   "p-5-of-100"
   正则: ✗ 需要新增正则
   Few-shot: ✓ 可处理


┌─────────────────────────────────────────────────────────────────────┐
│ 实际测试结果                                                           │
└─────────────────────────────────────────────────────────────────────┘

文档: pages-78.pdf

方案 1（正则）:
  TOC 检测: ✓ 成功
  页脚清理: ✓ 成功
  页码判断: ✓ 正确（无页码）
  LLM 调用: 2 次（TOC检测 + 页码判断）
  
方案 2（Few-shot）:
  TOC 检测: ✓ 成功
  页码判断: ✓ 正确（无页码）
  LLM 调用: 2 次（TOC检测 + 页码判断）
  
结论: 
  - 两种方案结果一致
  - Few-shot 更简洁（少了 _remove_page_footers 方法）
  - Few-shot 更灵活（处理未知格式）


┌─────────────────────────────────────────────────────────────────────┐
│ Few-shot Examples 设计原则                                            │
└─────────────────────────────────────────────────────────────────────┘

✓ 覆盖典型场景：
  - 有页码 + 有页脚
  - 无页码 + 有页脚
  - 有页码 + 无页脚
  - 不同语言（中文/英文）
  - 不同格式（章节/小节）

✓ 清晰的标注：
  - Input: 明确显示原始内容
  - Analysis: 解释判断逻辑
  - Answer: 给出明确结论

✓ 正反例结合：
  - 正例：有页码的情况
  - 反例：无页码的情况
  - 对比：强化理解

✓ 渐进式复杂度：
  - Example 1: 简单情况
  - Example 2-3: 中等复杂
  - Example 4-5: 复杂情况


┌─────────────────────────────────────────────────────────────────────┐
│ 代码对比                                                              │
└─────────────────────────────────────────────────────────────────────┘

【方案 1：正则匹配】
代码行数: ~80 行
  - _remove_page_footers(): ~25 行（正则匹配逻辑）
  - detect_page_numbers_in_toc(): ~35 行
  - 正则表达式: 3-4 个

复杂度: 高
维护性: 低
扩展性: 低（需要不断添加正则）


【方案 2：Few-shot Prompting】
代码行数: ~60 行
  - detect_page_numbers_in_toc(): ~60 行
  - 删除了 _remove_page_footers()

复杂度: 低
维护性: 高（只需调整 prompt）
扩展性: 高（添加 examples 即可）


┌─────────────────────────────────────────────────────────────────────┐
│ 总结与建议                                                            │
└─────────────────────────────────────────────────────────────────────┘

选择 Few-shot Prompting 的理由：

1. 🎯 更智能：LLM 能理解语义，不依赖固定模式
2. 🔧 更简洁：删除复杂的正则匹配代码
3. 🚀 更灵活：轻松处理新的页脚格式
4. 📈 更易维护：调整 prompt 比写正则简单
5. 💰 成本相当：不增加额外 LLM 调用

最佳实践：
  ✓ 设计 5-10 个高质量 few-shot examples
  ✓ 覆盖常见和罕见的页脚格式
  ✓ 给出清晰的推理过程
  ✓ 使用低温度参数（0.1）保证稳定性
  ✓ 在 system prompt 中明确区分"TOC页码"和"页脚"

这就是现代 AI 工程的优势：
  用 LLM 解决传统需要大量规则的问题！

""")
